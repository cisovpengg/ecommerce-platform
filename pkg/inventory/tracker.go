// @ai-generated by cursor
// Inventory tracking and product availability management

package inventory

import (
	"net/http"
	"sync"

	"github.com/gin-gonic/gin"
)

// Product represents a product in the catalog
type Product struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Price       float64  `json:"price"`
	Category    string   `json:"category"`
	ImageURL    string   `json:"image_url"`
	Tags        []string `json:"tags"`
}

// InventoryItem tracks stock levels for a product
type InventoryItem struct {
	ProductID     string `json:"product_id"`
	QuantityOnHand int   `json:"quantity_on_hand"`
	ReorderLevel   int   `json:"reorder_level"`
	ReorderQuantity int  `json:"reorder_quantity"`
	IsAvailable    bool  `json:"is_available"`
}

// Availability response for stock checks
type Availability struct {
	ProductID    string `json:"product_id"`
	Available    bool   `json:"available"`
	Quantity     int    `json:"quantity"`
	EstimatedRestock string `json:"estimated_restock,omitempty"`
}

var (
	products  = make(map[string]*Product)
	inventory = make(map[string]*InventoryItem)
	mu        sync.RWMutex
)

func init() {
	// Seed demo products
	seedProducts()
}

// ListProducts returns all products in the catalog
func ListProducts(c *gin.Context) {
	category := c.Query("category")

	mu.RLock()
	defer mu.RUnlock()

	var result []*Product
	for _, p := range products {
		if category == "" || p.Category == category {
			result = append(result, p)
		}
	}

	c.JSON(http.StatusOK, gin.H{"products": result, "count": len(result)})
}

// GetProduct returns a single product by ID
func GetProduct(c *gin.Context) {
	productID := c.Param("id")

	mu.RLock()
	product, exists := products[productID]
	mu.RUnlock()

	if !exists {
		c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"product": product})
}

// CheckAvailability returns stock availability for a product
func CheckAvailability(c *gin.Context) {
	productID := c.Param("id")

	mu.RLock()
	inv, exists := inventory[productID]
	mu.RUnlock()

	if !exists {
		c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
		return
	}

	availability := Availability{
		ProductID: productID,
		Available: inv.IsAvailable && inv.QuantityOnHand > 0,
		Quantity:  inv.QuantityOnHand,
	}

	if !availability.Available {
		availability.EstimatedRestock = "3-5 business days"
	}

	c.JSON(http.StatusOK, gin.H{"availability": availability})
}

func seedProducts() {
	demoProducts := []*Product{
		{
			ID:          "prod-001",
			Name:        "Wireless Headphones",
			Description: "Premium noise-canceling wireless headphones",
			Price:       199.99,
			Category:    "electronics",
			Tags:        []string{"audio", "wireless", "premium"},
		},
		{
			ID:          "prod-002",
			Name:        "Laptop Stand",
			Description: "Ergonomic aluminum laptop stand",
			Price:       49.99,
			Category:    "accessories",
			Tags:        []string{"ergonomic", "desk", "aluminum"},
		},
		{
			ID:          "prod-003",
			Name:        "USB-C Hub",
			Description: "7-in-1 USB-C hub with HDMI and SD card reader",
			Price:       79.99,
			Category:    "electronics",
			Tags:        []string{"usb", "hub", "connectivity"},
		},
	}

	for _, p := range demoProducts {
		products[p.ID] = p
		inventory[p.ID] = &InventoryItem{
			ProductID:       p.ID,
			QuantityOnHand:  100,
			ReorderLevel:    10,
			ReorderQuantity: 50,
			IsAvailable:     true,
		}
	}
}
