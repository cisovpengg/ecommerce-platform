// @ai-generated by claude-code
// Checkout processing and order management
//
// This package handles the complete checkout flow including:
// - Cart validation and inventory verification
// - Payment processing integration
// - Order creation and confirmation
// - Email notification triggers

package checkout

import (
	"net/http"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// OrderStatus represents the current state of an order
type OrderStatus string

const (
	StatusPending    OrderStatus = "pending"
	StatusProcessing OrderStatus = "processing"
	StatusCompleted  OrderStatus = "completed"
	StatusFailed     OrderStatus = "failed"
	StatusCancelled  OrderStatus = "cancelled"
)

// OrderItem represents a line item in an order
type OrderItem struct {
	ProductID string  `json:"product_id"`
	Name      string  `json:"name"`
	Quantity  int     `json:"quantity"`
	UnitPrice float64 `json:"unit_price"`
	Subtotal  float64 `json:"subtotal"`
}

// ShippingAddress contains delivery information
type ShippingAddress struct {
	Name       string `json:"name"`
	Street     string `json:"street"`
	City       string `json:"city"`
	State      string `json:"state"`
	PostalCode string `json:"postal_code"`
	Country    string `json:"country"`
}

// Order represents a completed checkout
type Order struct {
	ID              string          `json:"id"`
	UserID          string          `json:"user_id"`
	Items           []OrderItem     `json:"items"`
	ShippingAddress ShippingAddress `json:"shipping_address"`
	Subtotal        float64         `json:"subtotal"`
	Tax             float64         `json:"tax"`
	ShippingCost    float64         `json:"shipping_cost"`
	Total           float64         `json:"total"`
	Status          OrderStatus     `json:"status"`
	PaymentMethod   string          `json:"payment_method"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
}

// CheckoutRequest contains all information needed to process checkout
type CheckoutRequest struct {
	Items           []OrderItem     `json:"items" binding:"required,min=1"`
	ShippingAddress ShippingAddress `json:"shipping_address" binding:"required"`
	PaymentMethod   string          `json:"payment_method" binding:"required"`
}

var (
	orders   = make(map[string]*Order)
	ordersMu sync.RWMutex
)

// ProcessCheckout handles the complete checkout flow
func ProcessCheckout(c *gin.Context) {
	userID := c.GetHeader("X-User-ID")
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
		return
	}

	var req CheckoutRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
		return
	}

	// Validate items exist and calculate totals
	if len(req.Items) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Cart is empty"})
		return
	}

	// Calculate order totals
	subtotal := 0.0
	for i := range req.Items {
		req.Items[i].Subtotal = req.Items[i].UnitPrice * float64(req.Items[i].Quantity)
		subtotal += req.Items[i].Subtotal
	}

	tax := calculateTax(subtotal, req.ShippingAddress.State)
	shippingCost := calculateShipping(req.Items, req.ShippingAddress)
	total := subtotal + tax + shippingCost

	// Create the order
	order := &Order{
		ID:              uuid.New().String(),
		UserID:          userID,
		Items:           req.Items,
		ShippingAddress: req.ShippingAddress,
		Subtotal:        subtotal,
		Tax:             tax,
		ShippingCost:    shippingCost,
		Total:           total,
		Status:          StatusPending,
		PaymentMethod:   req.PaymentMethod,
		CreatedAt:       time.Now(),
		UpdatedAt:       time.Now(),
	}

	// Process payment (simulated)
	paymentSuccess := processPayment(order)
	if !paymentSuccess {
		order.Status = StatusFailed
		c.JSON(http.StatusPaymentRequired, gin.H{
			"error": "Payment processing failed",
			"order": order,
		})
		return
	}

	order.Status = StatusCompleted
	order.UpdatedAt = time.Now()

	// Store the order
	ordersMu.Lock()
	orders[order.ID] = order
	ordersMu.Unlock()

	c.JSON(http.StatusCreated, gin.H{
		"message": "Order placed successfully",
		"order":   order,
	})
}

// GetOrder retrieves an order by ID
func GetOrder(c *gin.Context) {
	orderID := c.Param("id")

	ordersMu.RLock()
	order, exists := orders[orderID]
	ordersMu.RUnlock()

	if !exists {
		c.JSON(http.StatusNotFound, gin.H{"error": "Order not found"})
		return
	}

	// Verify ownership
	userID := c.GetHeader("X-User-ID")
	if order.UserID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"order": order})
}

// calculateTax computes sales tax based on state
func calculateTax(subtotal float64, state string) float64 {
	// Simplified tax rates by state
	taxRates := map[string]float64{
		"CA": 0.0725,
		"NY": 0.08,
		"TX": 0.0625,
		"WA": 0.065,
	}

	rate, exists := taxRates[state]
	if !exists {
		rate = 0.05 // Default rate
	}

	return subtotal * rate
}

// calculateShipping determines shipping cost based on items and destination
func calculateShipping(items []OrderItem, address ShippingAddress) float64 {
	totalItems := 0
	for _, item := range items {
		totalItems += item.Quantity
	}

	// Base rate + per item cost
	baseCost := 5.99
	perItemCost := 0.99

	return baseCost + (float64(totalItems) * perItemCost)
}

// processPayment simulates payment processing
func processPayment(order *Order) bool {
	// In production, this would integrate with a payment gateway
	// For demo purposes, always succeeds
	return true
}
