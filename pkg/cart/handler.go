// @ai-generated by copilot
// Shopping cart management handlers

package cart

import (
	"net/http"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// CartItem represents an item in the shopping cart
type CartItem struct {
	ID        string    `json:"id"`
	ProductID string    `json:"product_id"`
	Name      string    `json:"name"`
	Quantity  int       `json:"quantity"`
	Price     float64   `json:"price"`
	AddedAt   time.Time `json:"added_at"`
}

// Cart represents a user's shopping cart
type Cart struct {
	ID        string     `json:"id"`
	UserID    string     `json:"user_id"`
	Items     []CartItem `json:"items"`
	Total     float64    `json:"total"`
	UpdatedAt time.Time  `json:"updated_at"`
}

var (
	carts = make(map[string]*Cart)
	mu    sync.RWMutex
)

// GetCart returns the current user's cart
func GetCart(c *gin.Context) {
	userID := c.GetHeader("X-User-ID")
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User ID required"})
		return
	}

	mu.RLock()
	cart, exists := carts[userID]
	mu.RUnlock()

	if !exists {
		cart = &Cart{
			ID:        uuid.New().String(),
			UserID:    userID,
			Items:     []CartItem{},
			Total:     0,
			UpdatedAt: time.Now(),
		}
		mu.Lock()
		carts[userID] = cart
		mu.Unlock()
	}

	c.JSON(http.StatusOK, gin.H{"cart": cart})
}

// AddItem adds an item to the cart
func AddItem(c *gin.Context) {
	userID := c.GetHeader("X-User-ID")
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User ID required"})
		return
	}

	var req struct {
		ProductID string  `json:"product_id" binding:"required"`
		Name      string  `json:"name" binding:"required"`
		Quantity  int     `json:"quantity" binding:"required,min=1"`
		Price     float64 `json:"price" binding:"required,min=0"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	mu.Lock()
	defer mu.Unlock()

	cart, exists := carts[userID]
	if !exists {
		cart = &Cart{
			ID:     uuid.New().String(),
			UserID: userID,
			Items:  []CartItem{},
		}
		carts[userID] = cart
	}

	// Check if product already in cart
	for i, item := range cart.Items {
		if item.ProductID == req.ProductID {
			cart.Items[i].Quantity += req.Quantity
			cart.UpdatedAt = time.Now()
			recalculateTotal(cart)
			c.JSON(http.StatusOK, gin.H{"cart": cart})
			return
		}
	}

	// Add new item
	newItem := CartItem{
		ID:        uuid.New().String(),
		ProductID: req.ProductID,
		Name:      req.Name,
		Quantity:  req.Quantity,
		Price:     req.Price,
		AddedAt:   time.Now(),
	}

	cart.Items = append(cart.Items, newItem)
	cart.UpdatedAt = time.Now()
	recalculateTotal(cart)

	c.JSON(http.StatusCreated, gin.H{"cart": cart, "item": newItem})
}

// RemoveItem removes an item from the cart
func RemoveItem(c *gin.Context) {
	userID := c.GetHeader("X-User-ID")
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User ID required"})
		return
	}

	itemID := c.Param("id")

	mu.Lock()
	defer mu.Unlock()

	cart, exists := carts[userID]
	if !exists {
		c.JSON(http.StatusNotFound, gin.H{"error": "Cart not found"})
		return
	}

	for i, item := range cart.Items {
		if item.ID == itemID {
			cart.Items = append(cart.Items[:i], cart.Items[i+1:]...)
			cart.UpdatedAt = time.Now()
			recalculateTotal(cart)
			c.JSON(http.StatusOK, gin.H{"cart": cart})
			return
		}
	}

	c.JSON(http.StatusNotFound, gin.H{"error": "Item not found in cart"})
}

func recalculateTotal(cart *Cart) {
	total := 0.0
	for _, item := range cart.Items {
		total += item.Price * float64(item.Quantity)
	}
	cart.Total = total
}
